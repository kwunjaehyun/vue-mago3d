define(["./GeometryOffsetAttribute-718fa138","./arrayRemoveDuplicates-3fea1e5f","./Transforms-79117a7b","./Cartesian2-8646c5a1","./Check-24483042","./ComponentDatatype-1a100acd","./PolylineVolumeGeometryLibrary-4d0ebb44","./CorridorGeometryLibrary-1ea8b9ee","./when-54335d57","./GeometryAttribute-374f805d","./GeometryAttributes-caa08d6c","./IndexDatatype-82ceea78","./Math-d6182036","./PolygonPipeline-97a7160d","./VertexFormat-81ec7207","./RuntimeError-88a32665","./WebGLConstants-95ceb4e9","./EllipsoidTangentPlane-325a8e68","./IntersectionTests-5394f658","./Plane-13ae4b1b","./PolylinePipeline-3803a6c2","./EllipsoidGeodesic-cc216670","./EllipsoidRhumbLine-2b7999f3"],function(x,h,g,at,t,it,p,ot,nt,st,lt,dt,ut,N,D,e,r,a,i,o,n,s,l){"use strict";var mt=new at.Cartesian3,yt=new at.Cartesian3,ft=new at.Cartesian3,pt=new at.Cartesian3,M=new at.Cartesian3,ct=new at.Cartesian3,ht=new at.Cartesian3,gt=new at.Cartesian3;function C(t,e){for(var r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function Ct(t,e,r,a,i,o){var n=t.normals,s=t.tangents,l=t.bitangents,d=at.Cartesian3.normalize(at.Cartesian3.cross(r,e,ht),ht);o.normal&&ot.CorridorGeometryLibrary.addAttribute(n,e,a,i),o.tangent&&ot.CorridorGeometryLibrary.addAttribute(s,d,a,i),o.bitangent&&ot.CorridorGeometryLibrary.addAttribute(l,r,a,i)}function O(t,e,r){var a,i=t.positions,o=t.corners,n=t.endPositions,s=t.lefts,l=t.normals,d=new lt.GeometryAttributes,u=0,m=0,y=0;for(D=0;D<i.length;D+=2)u+=a=i[D].length-3,y+=2*a,m+=i[D+1].length-3;for(u+=3,m+=3,D=0;D<o.length;D++){z=o[D];var f=o[D].leftPositions;nt.defined(f)?u+=a=f.length:m+=a=o[D].rightPositions.length,y+=a}var p,c=nt.defined(n);c&&(u+=p=n[0].length-3,m+=p,y+=6*(p/=3));var h,g,C,b,v,A,_=u+m,w=new Float64Array(_),T={normals:e.normal?new Float32Array(_):void 0,tangents:e.tangent?new Float32Array(_):void 0,bitangents:e.bitangent?new Float32Array(_):void 0},G=0,E=_-1,V=mt,F=yt,L=p/2,P=dt.IndexDatatype.createTypedArray(_/3,y),x=0;if(c){A=ft,v=pt;for(var N=n[0],V=at.Cartesian3.fromArray(l,0,V),F=at.Cartesian3.fromArray(s,0,F),D=0;D<L;D++)A=at.Cartesian3.fromArray(N,3*(L-1-D),A),v=at.Cartesian3.fromArray(N,3*(L+D),v),ot.CorridorGeometryLibrary.addAttribute(w,v,G),ot.CorridorGeometryLibrary.addAttribute(w,A,void 0,E),Ct(T,V,F,G,E,e),b=(g=G/3)+1,C=(h=(E-2)/3)-1,P[x++]=h,P[x++]=g,P[x++]=C,P[x++]=C,P[x++]=g,P[x++]=b,G+=3,E-=3}var M,O,I=0,S=0,R=i[I++],k=i[I++];for(w.set(R,G),w.set(k,E-k.length+1),F=at.Cartesian3.fromArray(s,S,F),a=k.length-3,D=0;D<a;D+=3)M=r.geodeticSurfaceNormal(at.Cartesian3.fromArray(R,D,ht),ht),O=r.geodeticSurfaceNormal(at.Cartesian3.fromArray(k,a-D,gt),gt),Ct(T,V=at.Cartesian3.normalize(at.Cartesian3.add(M,O,V),V),F,G,E,e),b=(g=G/3)+1,C=(h=(E-2)/3)-1,P[x++]=h,P[x++]=g,P[x++]=C,P[x++]=C,P[x++]=g,P[x++]=b,G+=3,E-=3;for(M=r.geodeticSurfaceNormal(at.Cartesian3.fromArray(R,a,ht),ht),O=r.geodeticSurfaceNormal(at.Cartesian3.fromArray(k,a,gt),gt),V=at.Cartesian3.normalize(at.Cartesian3.add(M,O,V),V),S+=3,D=0;D<o.length;D++){var H,z,U,B,Y=(z=o[D]).leftPositions,W=z.rightPositions,q=ct,J=ft,j=pt;if(V=at.Cartesian3.fromArray(l,S,V),nt.defined(Y)){for(Ct(T,V,F,void 0,E,e),E-=3,U=b,B=C,H=0;H<Y.length/3;H++)q=at.Cartesian3.fromArray(Y,3*H,q),P[x++]=U,P[x++]=B-H-1,P[x++]=B-H,ot.CorridorGeometryLibrary.addAttribute(w,q,void 0,E),J=at.Cartesian3.fromArray(w,3*(B-H-1),J),j=at.Cartesian3.fromArray(w,3*U,j),Ct(T,V,F=at.Cartesian3.normalize(at.Cartesian3.subtract(J,j,F),F),void 0,E,e),E-=3;q=at.Cartesian3.fromArray(w,3*U,q),J=at.Cartesian3.subtract(at.Cartesian3.fromArray(w,3*B,J),q,J),j=at.Cartesian3.subtract(at.Cartesian3.fromArray(w,3*(B-H),j),q,j),Ct(T,V,F=at.Cartesian3.normalize(at.Cartesian3.add(J,j,F),F),G,void 0,e),G+=3}else{for(Ct(T,V,F,G,void 0,e),G+=3,U=C,B=b,H=0;H<W.length/3;H++)q=at.Cartesian3.fromArray(W,3*H,q),P[x++]=U,P[x++]=B+H,P[x++]=B+H+1,ot.CorridorGeometryLibrary.addAttribute(w,q,G),J=at.Cartesian3.fromArray(w,3*U,J),j=at.Cartesian3.fromArray(w,3*(B+H),j),Ct(T,V,F=at.Cartesian3.normalize(at.Cartesian3.subtract(J,j,F),F),G,void 0,e),G+=3;q=at.Cartesian3.fromArray(w,3*U,q),J=at.Cartesian3.subtract(at.Cartesian3.fromArray(w,3*(B+H),J),q,J),j=at.Cartesian3.subtract(at.Cartesian3.fromArray(w,3*B,j),q,j),Ct(T,V,F=at.Cartesian3.normalize(at.Cartesian3.negate(at.Cartesian3.add(j,J,F),F),F),void 0,E,e),E-=3}for(R=i[I++],k=i[I++],R.splice(0,3),k.splice(k.length-3,3),w.set(R,G),w.set(k,E-k.length+1),a=k.length-3,S+=3,F=at.Cartesian3.fromArray(s,S,F),H=0;H<k.length;H+=3)M=r.geodeticSurfaceNormal(at.Cartesian3.fromArray(R,H,ht),ht),O=r.geodeticSurfaceNormal(at.Cartesian3.fromArray(k,a-H,gt),gt),Ct(T,V=at.Cartesian3.normalize(at.Cartesian3.add(M,O,V),V),F,G,E,e),g=(b=G/3)-1,h=(C=(E-2)/3)+1,P[x++]=h,P[x++]=g,P[x++]=C,P[x++]=C,P[x++]=g,P[x++]=b,G+=3,E-=3;G-=3,E+=3}if(Ct(T,V=at.Cartesian3.fromArray(l,l.length-3,V),F,G,E,e),c){G+=3,E-=3,A=ft,v=pt;var K=n[1];for(D=0;D<L;D++)A=at.Cartesian3.fromArray(K,3*(p-D-1),A),v=at.Cartesian3.fromArray(K,3*D,v),ot.CorridorGeometryLibrary.addAttribute(w,A,void 0,E),ot.CorridorGeometryLibrary.addAttribute(w,v,G),Ct(T,V,F,G,E,e),g=(b=G/3)-1,h=(C=(E-2)/3)+1,P[x++]=h,P[x++]=g,P[x++]=C,P[x++]=C,P[x++]=g,P[x++]=b,G+=3,E-=3}if(d.position=new st.GeometryAttribute({componentDatatype:it.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:w}),e.st){var Q=new Float32Array(_/3*2),X=0;if(c){u/=3,m/=3;var Z,$=Math.PI/(p+1),tt=1/(u-p+1),et=1/(m-p+1),rt=p/2;for(D=1+rt;D<p+1;D++)Z=ut.CesiumMath.PI_OVER_TWO+$*D,Q[X++]=et*(1+Math.cos(Z)),Q[X++]=.5*(1+Math.sin(Z));for(D=1;D<m-p+1;D++)Q[X++]=D*et,Q[X++]=0;for(D=p;rt<D;D--)Z=ut.CesiumMath.PI_OVER_TWO-D*$,Q[X++]=1-et*(1+Math.cos(Z)),Q[X++]=.5*(1+Math.sin(Z));for(D=rt;0<D;D--)Z=ut.CesiumMath.PI_OVER_TWO-$*D,Q[X++]=1-tt*(1+Math.cos(Z)),Q[X++]=.5*(1+Math.sin(Z));for(D=u-p;0<D;D--)Q[X++]=D*tt,Q[X++]=1;for(D=1;D<1+rt;D++)Z=ut.CesiumMath.PI_OVER_TWO+$*D,Q[X++]=tt*(1+Math.cos(Z)),Q[X++]=.5*(1+Math.sin(Z))}else{for(tt=1/((u/=3)-1),et=1/((m/=3)-1),D=0;D<m;D++)Q[X++]=D*et,Q[X++]=0;for(D=u;0<D;D--)Q[X++]=(D-1)*tt,Q[X++]=1}d.st=new st.GeometryAttribute({componentDatatype:it.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:Q})}return e.normal&&(d.normal=new st.GeometryAttribute({componentDatatype:it.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T.normals})),e.tangent&&(d.tangent=new st.GeometryAttribute({componentDatatype:it.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T.tangents})),e.bitangent&&(d.bitangent=new st.GeometryAttribute({componentDatatype:it.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:T.bitangents})),{attributes:d,indices:P}}function I(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(var a=3;a<t.length;a+=3){var i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}function b(t,e){var r=new D.VertexFormat({position:e.position,normal:e.normal||e.bitangent||t.shadowVolume,tangent:e.tangent,bitangent:e.normal||e.bitangent,st:e.st}),a=t.ellipsoid,i=O(ot.CorridorGeometryLibrary.computePositions(t),r,a),o=t.height,n=t.extrudedHeight,s=i.attributes,l=i.indices,d=s.position.values,u=d.length,m=new Float64Array(6*u),y=new Float64Array(u);y.set(d);var f=new Float64Array(4*u),f=I(d=N.PolygonPipeline.scaleToGeodeticHeight(d,o,a),0,f);f=I(y=N.PolygonPipeline.scaleToGeodeticHeight(y,n,a),2*u,f),m.set(d),m.set(y,u),m.set(f,2*u),s.position.values=m,s=function(t,e){if(!(e.normal||e.tangent||e.bitangent||e.st))return t;var r,a,i=t.position.values;(e.normal||e.bitangent)&&(r=t.normal.values,a=t.bitangent.values);var o=t.position.values.length/18,n=3*o,s=2*o,l=2*n;if(e.normal||e.bitangent||e.tangent){for(var d,u=e.normal?new Float32Array(6*n):void 0,m=e.tangent?new Float32Array(6*n):void 0,y=e.bitangent?new Float32Array(6*n):void 0,f=mt,p=yt,c=ft,h=pt,g=M,C=ct,b=l,v=0;v<n;v+=3){var A=b+l,f=at.Cartesian3.fromArray(i,v,f),p=at.Cartesian3.fromArray(i,v+n,p),c=at.Cartesian3.fromArray(i,(v+3)%n,c);p=at.Cartesian3.subtract(p,f,p),c=at.Cartesian3.subtract(c,f,c),h=at.Cartesian3.normalize(at.Cartesian3.cross(p,c,h),h),e.normal&&(ot.CorridorGeometryLibrary.addAttribute(u,h,A),ot.CorridorGeometryLibrary.addAttribute(u,h,A+3),ot.CorridorGeometryLibrary.addAttribute(u,h,b),ot.CorridorGeometryLibrary.addAttribute(u,h,b+3)),(e.tangent||e.bitangent)&&(C=at.Cartesian3.fromArray(r,v,C),e.bitangent&&(ot.CorridorGeometryLibrary.addAttribute(y,C,A),ot.CorridorGeometryLibrary.addAttribute(y,C,A+3),ot.CorridorGeometryLibrary.addAttribute(y,C,b),ot.CorridorGeometryLibrary.addAttribute(y,C,b+3)),e.tangent&&(g=at.Cartesian3.normalize(at.Cartesian3.cross(C,h,g),g),ot.CorridorGeometryLibrary.addAttribute(m,g,A),ot.CorridorGeometryLibrary.addAttribute(m,g,A+3),ot.CorridorGeometryLibrary.addAttribute(m,g,b),ot.CorridorGeometryLibrary.addAttribute(m,g,b+3))),b+=6}if(e.normal){for(u.set(r),v=0;v<n;v+=3)u[v+n]=-r[v],u[v+n+1]=-r[v+1],u[v+n+2]=-r[v+2];t.normal.values=u}else t.normal=void 0;e.bitangent?(y.set(a),y.set(a,n),t.bitangent.values=y):t.bitangent=void 0,e.tangent&&(d=t.tangent.values,m.set(d),m.set(d,n),t.tangent.values=m)}if(e.st){var _=t.st.values,w=new Float32Array(6*s);w.set(_),w.set(_,s);for(var T=2*s,G=0;G<2;G++){for(w[T++]=_[0],w[T++]=_[1],v=2;v<s;v+=2){var E=_[v],V=_[v+1];w[T++]=E,w[T++]=V,w[T++]=E,w[T++]=V}w[T++]=_[0],w[T++]=_[1]}t.st.values=w}return t}(s,e);var p,c,h=u/3;if(t.shadowVolume){for(var g=s.normal.values,u=g.length,C=new Float32Array(6*u),b=0;b<u;b++)g[b]=-g[b];C.set(g,u),C=I(g,4*u,C),s.extrudeDirection=new st.GeometryAttribute({componentDatatype:it.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C}),e.normal||(s.normal=void 0)}nt.defined(t.offsetAttribute)&&(c=new Uint8Array(6*h),c=t.offsetAttribute===x.GeometryOffsetAttribute.TOP?(c=x.arrayFill(c,1,0,h),x.arrayFill(c,1,2*h,4*h)):(p=t.offsetAttribute===x.GeometryOffsetAttribute.NONE?0:1,x.arrayFill(c,p)),s.applyOffset=new st.GeometryAttribute({componentDatatype:it.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:c}));var v=l.length,A=h+h,_=dt.IndexDatatype.createTypedArray(m.length/3,2*v+3*A);_.set(l);var w,T,G,E,V=v;for(b=0;b<v;b+=3){var F=l[b],L=l[b+1],P=l[b+2];_[V++]=P+h,_[V++]=L+h,_[V++]=F+h}for(b=0;b<A;b+=2)G=(w=b+A)+1,E=(T=w+A)+1,_[V++]=w,_[V++]=T,_[V++]=G,_[V++]=G,_[V++]=T,_[V++]=E;return{attributes:s,indices:_}}var c=new at.Cartesian3,v=new at.Cartesian3,A=new at.Cartographic;function _(t,e,r,a,i,o){var n=at.Cartesian3.subtract(e,t,c);at.Cartesian3.normalize(n,n);var s=r.geodeticSurfaceNormal(t,v),l=at.Cartesian3.cross(n,s,c);at.Cartesian3.multiplyByScalar(l,a,l);var d=i.latitude,u=i.longitude,m=o.latitude,y=o.longitude;at.Cartesian3.add(t,l,v),r.cartesianToCartographic(v,A);var f=A.latitude,p=A.longitude,d=Math.min(d,f),u=Math.min(u,p),m=Math.max(m,f),y=Math.max(y,p);at.Cartesian3.subtract(t,l,v),r.cartesianToCartographic(v,A),f=A.latitude,p=A.longitude,d=Math.min(d,f),u=Math.min(u,p),m=Math.max(m,f),y=Math.max(y,p),i.latitude=d,i.longitude=u,o.latitude=m,o.longitude=y}var w=new at.Cartesian3,T=new at.Cartesian3,G=new at.Cartographic,E=new at.Cartographic;function d(t,e,r,a,i){t=C(t,e);var o=h.arrayRemoveDuplicates(t,at.Cartesian3.equalsEpsilon),n=o.length;if(n<2||r<=0)return new at.Rectangle;var s,l,d,u=.5*r;G.latitude=Number.POSITIVE_INFINITY,G.longitude=Number.POSITIVE_INFINITY,E.latitude=Number.NEGATIVE_INFINITY,E.longitude=Number.NEGATIVE_INFINITY,a===p.CornerType.ROUNDED&&(d=o[0],at.Cartesian3.subtract(d,o[1],w),at.Cartesian3.normalize(w,w),at.Cartesian3.multiplyByScalar(w,u,w),at.Cartesian3.add(d,w,T),e.cartesianToCartographic(T,A),s=A.latitude,l=A.longitude,G.latitude=Math.min(G.latitude,s),G.longitude=Math.min(G.longitude,l),E.latitude=Math.max(E.latitude,s),E.longitude=Math.max(E.longitude,l));for(var m=0;m<n-1;++m)_(o[m],o[m+1],e,u,G,E);var y=o[n-1];at.Cartesian3.subtract(y,o[n-2],w),at.Cartesian3.normalize(w,w),at.Cartesian3.multiplyByScalar(w,u,w),at.Cartesian3.add(y,w,T),_(y,T,e,u,G,E),a===p.CornerType.ROUNDED&&(e.cartesianToCartographic(T,A),s=A.latitude,l=A.longitude,G.latitude=Math.min(G.latitude,s),G.longitude=Math.min(G.longitude,l),E.latitude=Math.max(E.latitude,s),E.longitude=Math.max(E.longitude,l));var f=nt.defined(i)?i:new at.Rectangle;return f.north=E.latitude,f.south=G.latitude,f.east=E.longitude,f.west=G.longitude,f}function V(t){var e=(t=nt.defaultValue(t,nt.defaultValue.EMPTY_OBJECT)).positions,r=t.width,a=nt.defaultValue(t.height,0),i=nt.defaultValue(t.extrudedHeight,a);this._positions=e,this._ellipsoid=at.Ellipsoid.clone(nt.defaultValue(t.ellipsoid,at.Ellipsoid.WGS84)),this._vertexFormat=D.VertexFormat.clone(nt.defaultValue(t.vertexFormat,D.VertexFormat.DEFAULT)),this._width=r,this._height=Math.max(a,i),this._extrudedHeight=Math.min(a,i),this._cornerType=nt.defaultValue(t.cornerType,p.CornerType.ROUNDED),this._granularity=nt.defaultValue(t.granularity,ut.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=nt.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*at.Cartesian3.packedLength+at.Ellipsoid.packedLength+D.VertexFormat.packedLength+7}V.pack=function(t,e,r){r=nt.defaultValue(r,0);var a=t._positions,i=a.length;e[r++]=i;for(var o=0;o<i;++o,r+=at.Cartesian3.packedLength)at.Cartesian3.pack(a[o],e,r);return at.Ellipsoid.pack(t._ellipsoid,e,r),r+=at.Ellipsoid.packedLength,D.VertexFormat.pack(t._vertexFormat,e,r),r+=D.VertexFormat.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=nt.defaultValue(t._offsetAttribute,-1),e};var F=at.Ellipsoid.clone(at.Ellipsoid.UNIT_SPHERE),L=new D.VertexFormat,P={positions:void 0,ellipsoid:F,vertexFormat:L,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};return V.unpack=function(t,e,r){e=nt.defaultValue(e,0);for(var a=t[e++],i=new Array(a),o=0;o<a;++o,e+=at.Cartesian3.packedLength)i[o]=at.Cartesian3.unpack(t,e);var n=at.Ellipsoid.unpack(t,e,F);e+=at.Ellipsoid.packedLength;var s=D.VertexFormat.unpack(t,e,L);e+=D.VertexFormat.packedLength;var l=t[e++],d=t[e++],u=t[e++],m=t[e++],y=t[e++],f=1===t[e++],p=t[e];return nt.defined(r)?(r._positions=i,r._ellipsoid=at.Ellipsoid.clone(n,r._ellipsoid),r._vertexFormat=D.VertexFormat.clone(s,r._vertexFormat),r._width=l,r._height=d,r._extrudedHeight=u,r._cornerType=m,r._granularity=y,r._shadowVolume=f,r._offsetAttribute=-1===p?void 0:p,r):(P.positions=i,P.width=l,P.height=d,P.extrudedHeight=u,P.cornerType=m,P.granularity=y,P.shadowVolume=f,P.offsetAttribute=-1===p?void 0:p,new V(P))},V.computeRectangle=function(t,e){var r=(t=nt.defaultValue(t,nt.defaultValue.EMPTY_OBJECT)).positions,a=t.width;return d(r,nt.defaultValue(t.ellipsoid,at.Ellipsoid.WGS84),a,nt.defaultValue(t.cornerType,p.CornerType.ROUNDED),e)},V.createGeometry=function(t){var e=t._positions,r=t._width,a=t._ellipsoid,e=C(e,a),i=h.arrayRemoveDuplicates(e,at.Cartesian3.equalsEpsilon);if(!(i.length<2||r<=0)){var o,n,s,l,d=t._height,u=t._extrudedHeight,m=!ut.CesiumMath.equalsEpsilon(d,u,0,ut.CesiumMath.EPSILON2),y=t._vertexFormat,f={ellipsoid:a,positions:i,width:r,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!0};m?(f.height=d,f.extrudedHeight=u,f.shadowVolume=t._shadowVolume,f.offsetAttribute=t._offsetAttribute,l=b(f,y)):((l=O(ot.CorridorGeometryLibrary.computePositions(f),y,a)).attributes.position.values=N.PolygonPipeline.scaleToGeodeticHeight(l.attributes.position.values,d,a),nt.defined(t._offsetAttribute)&&(o=t._offsetAttribute===x.GeometryOffsetAttribute.NONE?0:1,n=l.attributes.position.values.length,s=new Uint8Array(n/3),x.arrayFill(s,o),l.attributes.applyOffset=new st.GeometryAttribute({componentDatatype:it.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:s})));var p=l.attributes,c=g.BoundingSphere.fromVertices(p.position.values,void 0,3);return y.position||(l.attributes.position.values=void 0),new st.Geometry({attributes:p,indices:l.indices,primitiveType:st.PrimitiveType.TRIANGLES,boundingSphere:c,offsetAttribute:t._offsetAttribute})}},V.createShadowVolume=function(t,e,r){var a=t._granularity,i=t._ellipsoid,o=e(a,i),n=r(a,i);return new V({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:o,height:n,vertexFormat:D.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(V.prototype,{rectangle:{get:function(){return nt.defined(this._rectangle)||(this._rectangle=d(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),function(t,e){return nt.defined(e)&&(t=V.unpack(t,e)),t._ellipsoid=at.Ellipsoid.clone(t._ellipsoid),V.createGeometry(t)}});
